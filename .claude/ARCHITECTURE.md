# V4.0 系统架构文档

> **版本**: 4.0
> **更新日期**: 2025-11-30
> **设计理念**: 林纳斯·托瓦兹的工程哲学 + 痛点驱动设计

---

## 📐 架构概览

V4.0采用**单一配置 + 分层记忆 + 迭代对抗**的架构设计，解决了V2.0/V3.1的所有痛点。

```
┌─────────────────────────────────────────────────┐
│          主控 Claude (Sonnet 4.5)               │
│  - 决策中心                                      │
│  - 流程协调                                      │
│  - 串行执行控制                                  │
│  - 验证Agent输出                                 │
│  - 迭代循环控制                                  │
└──────────────┬──────────────────────────────────┘
               │
               ├─► 调用 Task工具
               │   └─► Opus (P0架构、阶段1终审)
               │   └─► Gemini (阶段1 Designer、前端)
               │   └─► Haiku (阶段8 Git)
               │
               ├─► 调用 MCP Codex
               │   └─► 阶段1 Critic（红队攻击，多轮迭代）
               │   └─► 后端代码实现
               │
               └─► 4层记忆系统
                   ├─► L0: QUICK_RESUME.md
                   ├─► L1: PROJECT_CONTEXT.md
                   ├─► L2: MODULE_CONTEXT.md
                   └─► L3: HISTORY.md
```

---

## 🏗️ 核心组件

### 1. 单一配置文件（workflow.json）

**设计理念**：V3.1将配置拆分成多个文件导致无法执行，V4.0回归单一配置。

**结构**：

```json
{
  "version": "4.0",
  "workflow_name": "自主协作工作流系统 V4.0",

  "V4新增改进": { ... },
  "致主控Claude_V4": { ... },
  "superclaude_enhancement": { ... },
  "核心原则": {
    "V4_强制串行执行": { ... },
    "V4_立即Git提交": { ... },
    "V4_强制记录更新": { ... },
    "V4_强制交接文档": { ... }
  },
  "检查点与恢复机制": {
    "V4_四层记忆系统": { ... }
  },
  "模型选择策略": {
    "V4模型版本": {
      "Opus": "claude-4.5-opus",
      "Gemini": "gemini-3.0-pro",
      "Codex": "gpt-5.1-codex",
      ...
    }
  },
  "工作流阶段": [ ... ]
}
```

**行数**: 1324行（v2.0是1058行，增加266行）

---

### 2. 4层记忆系统

**设计目标**：30秒快速恢复 + 完整上下文保留

```
架构层次：
┌─────────────────────────────────────────────────┐
│ L0: QUICK_RESUME.md (最高优先级)                │
│  - 更新频率：每5-10分钟                          │
│  - 内容：最近3次操作 + 当前状态 + 恢复指令       │
│  - 目的：30秒恢复80%上下文                       │
└─────────────────────────────────────────────────┘
         ▼
┌─────────────────────────────────────────────────┐
│ L1: PROJECT_CONTEXT.md (项目级)                 │
│  - 更新频率：每个模块完成后                      │
│  - 内容：项目架构 + 已完成模块 + 待办模块        │
│  - 目的：理解项目全貌                           │
└─────────────────────────────────────────────────┘
         ▼
┌─────────────────────────────────────────────────┐
│ L2: MODULE_CONTEXT.md (模块级)                  │
│  - 更新频率：每个子模块完成后                    │
│  - 内容：模块设计 + 前后端状态 + 遗留问题        │
│  - 目的：理解当前模块                           │
└─────────────────────────────────────────────────┘
         ▼
┌─────────────────────────────────────────────────┐
│ L3: HISTORY.md (任务历史)                       │
│  - 更新频率：每个任务完成后追加                  │
│  - 内容：时间线 + Git提交ID + 决策记录          │
│  - 目的：完整历史追溯                           │
└─────────────────────────────────────────────────┘
```

**恢复流程**：

```python
def 恢复工作():
    # 步骤1：读取 L0（30秒）
    quick_resume = read("QUICK_RESUME.md")
    if 上下文足够:
        return 继续工作()

    # 步骤2：读取 L1（如需更多上下文）
    project_context = read("PROJECT_CONTEXT.md")
    if 上下文足够:
        return 继续工作()

    # 步骤3：读取 L2 和 L3（如需历史细节）
    module_context = read("MODULE_CONTEXT.md")
    history = read("HISTORY.md")
    return 继续工作()
```

---

### 3. 迭代对抗设计机制（阶段1）

**设计目标**：通过多轮循环迭代，不断改进设计直到无大错误后才交给Opus终审

**V4.0改进**：从一次性修正改为迭代循环改进

```
流程图（V4迭代对抗）：

┌────────────────────────────────────────────────┐
│ Step 1: Designer (Gemini 3.0 Pro)             │
│  - 起草完整设计（前后端）                      │
│  - 覆盖所有功能点                             │
│  - 输出：01-design-v1.md                      │
└────────────┬───────────────────────────────────┘
             │
             ▼
┌────────────────────────────────────────────────┐
│ Step 2: 迭代循环（最多5轮）                    │
│                                                │
│  ┌───────────────────────────────────┐         │
│  │ 2a. Critic (Codex 5.1) 攻击       │         │
│  │  - 找出所有漏洞和遗漏             │  ◄──┐   │
│  │  - 输出：01-critique-vN.md        │     │   │
│  └─────────┬─────────────────────────┘     │   │
│            │                               │   │
│            ▼                               │   │
│  ┌───────────────────────────────────┐     │   │
│  │ 2b. 主控检查退出条件               │     │   │
│  │  - Critical = 0 AND High = 0?     │     │   │
│  └─────────┬─────────────────────────┘     │   │
│            │                               │   │
│            ├─ YES → 退出循环               │   │
│            │                               │   │
│            ├─ NO AND N<5 → 继续修正        │   │
│            │         │                     │   │
│            │         ▼                     │   │
│            │  ┌─────────────────────┐      │   │
│            │  │ 2c. Designer修正     │      │   │
│            │  │  - 修复Critical/High │      │   │
│            │  │  - 输出：01-design-v{N+1}.md│ │
│            │  └───────────┬─────────┘      │   │
│            │              │                │   │
│            │              └────────────────┘   │
│            │                                   │
│            └─ N≥5 → 强制退出循环               │
│                                                │
└────────────┬───────────────────────────────────┘
             │
             ▼
┌────────────────────────────────────────────────┐
│ Step 3: Architect (Opus 4.5) 终审             │
│  - 审查最终设计 + 所有Critique                 │
│  - 林纳斯三问检查                              │
│  - 防遗漏检查                                  │
│  - 输出：01-architect-verdict.md               │
│  - 决策：✅ 批准 / ⚠️ 有条件批准 / ❌ 驳回      │
└────────────────────────────────────────────────┘
```

**迭代循环控制**：

| 条件 | 动作 |
|------|------|
| **Critical=0 AND High=0** | ✅ 退出循环，进入Architect终审 |
| **Critical>0 OR High>0** | ⚠️ Designer修正，Critic重新审查（第N+1轮） |
| **迭代次数≥5** | 🚫 强制退出循环，进入Architect终审 |

**检查清单**：

- ✅ 功能遗漏（是否缺少必要的子功能）
- ✅ 前后端对应（前端页面是否有对应后端API）
- ✅ 安全漏洞（SQL注入、XSS、认证缺陷）
- ✅ 性能问题（N+1查询、缺少索引）
- ✅ 边缘案例（空值、超长输入、并发）
- ✅ 过度设计（不必要的复杂度）

---

### 4. 渐进式休眠机制

**设计目标**：防止Agent执行超时

**实现方式**：在所有长任务Agent的prompt中注入休眠指令

```python
# 渐进式休眠时间表
休眠策略 = {
    "第1次": "工作5分钟 → 休眠10秒",
    "第2次": "工作5分钟 → 休眠30秒",
    "第3次及以后": "工作5分钟 → 休眠1分钟"
}

# 示例prompt模板
prompt = f"""
{任务描述}

⚠️ 重要：请在执行过程中渐进式休眠防止超时：
- 第1次工作5分钟后休眠10秒
- 第2次工作5分钟后休眠30秒
- 第3次及以后每工作5分钟休眠1分钟
"""
```

**应用阶段**：
- ✅ 阶段P0（Opus架构设计）
- ✅ 阶段1 所有步骤（Designer、Critic、Architect）
- ✅ 阶段4（Codex代码实现）

---

### 5. 强制串行执行架构

**设计目标**：防止并行执行混乱、状态不一致、遗漏检查

**主控循环逻辑**：

```python
class 主控Claude:
    def 执行工作流(self):
        while 还有任务:
            # 1. 选择当前任务（只能1个）
            当前任务 = self.选择下一个任务()

            # 2. 准备交接文档
            交接文档 = self.准备交接文档(
                任务=当前任务,
                包含渐进式休眠指令=True
            )

            # 3. 调用Agent（串行，等待完成）
            结果 = self.调用Agent(
                任务=当前任务,
                交接文档=交接文档,
                等待完成=True  # ⚠️ 强制等待
            )

            # 4. 验证Agent输出
            验证通过 = self.验证输出(
                检查文件是否生成=True,
                检查内容是否正确=True,
                检查测试是否通过=True
            )

            if not 验证通过:
                self.记录错误()
                self.进入修正流程()
                continue

            # 5. 更新记忆文件
            self.更新记忆(
                QUICK_RESUME=True,
                HISTORY=True
            )

            # 6. 如果测试通过，立即Git提交
            if 测试通过:
                self.立即Git提交()

            # 7. 选择下一个任务
```

**禁止行为**：

```python
# ❌ 禁止
def 错误的做法():
    # 同时调用多个Agent
    task1 = async_call_agent(agent1)
    task2 = async_call_agent(agent2)
    wait_all([task1, task2])

# ✅ 正确
def 正确的做法():
    # 串行调用
    result1 = call_agent(agent1)
    验证(result1)
    result2 = call_agent(agent2)
    验证(result2)
```

---

### 6. 立即Git提交机制

**设计目标**：防止工作丢失、保持Git历史清晰

**流程**：

```
阶段7（测试验证）通过
         │
         ▼
    ┌─────────┐
    │ V4检查： │
    │ 测试通过？│
    └─────────┘
         │ YES
         ▼
┌─────────────────────────┐
│ 阶段8（Git提交）        │
│  1. 检查git status       │
│  2. 暂存文件            │
│  3. Haiku生成commit msg │
│  4. 执行git commit       │
│  5. 更新HISTORY.md      │
└─────────────────────────┘
         │
         ▼
   ✅ 立即选择下一个任务
   （不能停顿）
```

**强制规则**：

- ✅ 测试通过后立即Git提交
- ❌ 不允许堆积多个功能再一起提交
- ✅ 每个任务单独提交一次
- ✅ 自动更新 HISTORY.md（任务ID + Commit Hash）

---

## 🔧 模型选择策略

V4.0为每个阶段和角色分配最适合的模型：

| 阶段/角色 | 模型 | 理由 |
|----------|------|------|
| **P0 架构设计** | Opus 4.5 | 深度思考、系统设计能力强 |
| **阶段1 Designer** | Gemini 3.0 Pro | 2M上下文、擅长前后端设计 |
| **阶段1 Critic** | Codex 5.1 | 代码理解强、找漏洞能力强 |
| **阶段1 Architect** | Opus 4.5 | 最终决策、质量把关 |
| **阶段4 前端** | Gemini 3.0 Pro | UI/UX设计、React开发 |
| **阶段4 后端** | Codex 5.1 | API开发、数据库设计 |
| **阶段5 审查** | Sonnet 4.5 | 平衡速度和质量 |
| **阶段7 测试** | Sonnet 4.5 | 测试策略制定 |
| **阶段8 Git** | Haiku 4.5 | 快速、低成本 |

---

## 🛡️ 安全与质量保证

### 林纳斯三问检查

在关键决策点强制执行：

```
1. 这是真实问题吗？
   - 拒绝过度设计
   - 三方对抗中Architect检查

2. 有没有更简单的方法？
   - 技术选型合理性
   - Critic检查复杂度

3. 这会破坏什么？
   - 向后兼容性
   - Architect终审检查
```

### 质量检查清单

每个阶段的验收标准：

- ✅ 代码规范遵守
- ✅ 测试通过（Exit Code 0）
- ✅ 编码验证（UTF-8 + 中文测试）
- ✅ 安全检查（SQL注入、XSS）
- ✅ 性能检查（响应时间、资源使用）

---

## 📊 性能优化

### 成本优化

通过智能模型选择降低成本：

```
简单任务 → Haiku（低成本）
常规任务 → Sonnet（平衡）
复杂任务 → Opus/Gemini（高质量）
代码任务 → Codex（专业）
```

### 上下文管理

4层记忆系统减少上下文加载：

```
L0 (500字) → 快速恢复
L1 (2000字) → 项目概览
L2 (1000字) → 模块详情
L3 (无限) → 完整历史
```

---

## 🔄 扩展性设计

### 支持的项目类型

- ✅ Web应用（前端/全栈）
- ✅ 后端API服务
- ✅ 数据库应用
- ✅ DevOps自动化
- ✅ 文档项目

### 自定义扩展点

- 🔧 模型版本可升级
- 🔧 阶段流程可调整
- 🔧 SuperClaude命令可扩展
- 🔧 检查清单可定制

---

## 📐 技术债务管理

V4.0采用"零容忍"策略：

```
每个阶段结束检查：
├─ 是否有 TODO？
├─ 是否有 FIXME？
├─ 是否有未解决的问题？
└─ 是否有技术债务？

记录到：
└─ MODULE_CONTEXT.md → 遗留问题部分
```

---

## 🎯 设计权衡

### 为什么回归单一配置文件？

**V3.1问题**：拆分成多个文件（orchestrator.json、agents.json、flows/*.json）导致无法执行

**V4.0解决**：单一workflow.json（1324行）

**权衡**：
- ✅ 优点：简单、可执行、易维护
- ⚠️ 缺点：文件较大
- 💡 平衡：通过分层记忆和文档模板组织复杂度

### 为什么强制串行执行？

**V2.0/V3.1问题**：并行执行导致状态混乱、遗漏检查

**V4.0解决**：主控强制串行执行

**权衡**：
- ✅ 优点：状态一致、可追溯、易验证
- ⚠️ 缺点：速度较慢
- 💡 平衡：通过渐进式休眠提高效率

---

## 📝 版本演进

```
V1.0（未记录）
  └─► 基础流程

V2.0 (2025-11-17)
  └─► 单一配置 + 9阶段流程
      │
      ├─► 痛点：中途停止、忘记Git、并行混乱
      │
      ▼
V3.1 (2025-11-28)
  └─► 拆分配置（失败，无法执行）
      │
      ├─► 痛点：配置拆分导致无法执行
      │
      ▼
V4.0 (2025-11-30)
  └─► 回归单一配置 + 7大改进
      ├─► ✅ 渐进式休眠
      ├─► ✅ 三方对抗设计
      ├─► ✅ 4层记忆系统
      ├─► ✅ 强制串行执行
      ├─► ✅ 立即Git提交
      ├─► ✅ P0用户审查
      └─► ✅ 强制交接文档
```

---

**🎉 V4.0架构已完成，所有设计决策均基于真实痛点！**
