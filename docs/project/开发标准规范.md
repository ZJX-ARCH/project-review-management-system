# ContiNew Admin 开发标准规范

> 基于 continew-admin system 模块的实际代码分析总结
>
> 最后更新：2025-12-21

---

## 目录

- [一、后端开发标准](#一后端开发标准)
  - [1.1 Controller 层规范](#11-controller-层规范)
  - [1.2 Service 层规范](#12-service-层规范)
  - [1.3 Mapper 层规范](#13-mapper-层规范)
  - [1.4 Model 层规范](#14-model-层规范)
  - [1.5 常用注解详解](#15-常用注解详解)
  - [1.6 工具类使用规范](#16-工具类使用规范)
- [二、前端开发标准](#二前端开发标准)
  - [2.1 页面组件结构](#21-页面组件结构)
  - [2.2 表单组件规范](#22-表单组件规范)
  - [2.3 API 调用规范](#23-api-调用规范)
  - [2.4 常用组件使用](#24-常用组件使用)
  - [2.5 Hooks 使用规范](#25-hooks-使用规范)
- [三、通用开发规范](#三通用开发规范)

---

## 一、后端开发标准

### 1.1 Controller 层规范

#### 1.1.1 基本结构

Controller 必须继承 `BaseController`，通过泛型指定 Service、响应类型、查询类型、请求类型。

```java
/**
 * 用户管理 API
 *
 * @author Charles7c
 * @since 2023/2/20 21:00
 */
@Tag(name = "用户管理 API")
@Validated
@RestController
@RequiredArgsConstructor
@CrudRequestMapping(value = "/system/user", api = {Api.PAGE, Api.LIST, Api.GET, Api.CREATE, Api.UPDATE,
    Api.BATCH_DELETE, Api.EXPORT, Api.DICT})
public class UserController extends BaseController<UserService, UserResp, UserDetailResp, UserQuery, UserReq> {
    // 实现自定义 API
}
```

**关键要点：**

1. **类注解组合**
   - `@Tag(name = "xxx API")` - Swagger 文档标签，必须包含
   - `@Validated` - 启用参数校验
   - `@RestController` - 标记为 REST 控制器
   - `@RequiredArgsConstructor` - Lombok 自动生成构造器注入

2. **路径映射注解**
   - 使用 `@CrudRequestMapping` 替代 `@RequestMapping`
   - 通过 `api` 参数指定需要的通用 CRUD API
   - 可选的 API 类型：
     - `Api.PAGE` - 分页查询
     - `Api.LIST` - 列表查询
     - `Api.TREE` - 树形查询
     - `Api.GET` - 详情查询
     - `Api.CREATE` - 新增
     - `Api.UPDATE` - 修改
     - `Api.BATCH_DELETE` - 批量删除
     - `Api.EXPORT` - 导出
     - `Api.DICT` - 字典数据
     - `Api.TREE_DICT` - 树形字典

3. **继承 BaseController**
   - 第一个泛型：Service 接口类型
   - 第二个泛型：列表响应类型
   - 第三个泛型：详情响应类型
   - 第四个泛型：查询条件类型
   - 第五个泛型：请求参数类型

#### 1.1.2 简单 Controller（纯 CRUD）

对于只需要基本 CRUD 的模块，可以不写任何方法：

```java
/**
 * 部门管理 API
 *
 * @author Charles7c
 * @since 2023/1/22 17:50
 */
@Tag(name = "部门管理 API")
@RestController
@CrudRequestMapping(value = "/system/dept", api = {Api.TREE, Api.GET, Api.CREATE, Api.UPDATE, Api.BATCH_DELETE,
    Api.EXPORT, Api.TREE_DICT})
public class DeptController extends BaseController<DeptService, DeptResp, DeptResp, DeptQuery, DeptReq> {
    // 无需写任何代码，BaseController 已提供所有 CRUD 功能
}
```

#### 1.1.3 复杂 Controller（自定义 API）

需要额外业务逻辑时，添加自定义方法：

```java
@Tag(name = "用户管理 API")
@Validated
@RestController
@RequiredArgsConstructor
@CrudRequestMapping(value = "/system/user", api = {Api.PAGE, Api.LIST, Api.GET, Api.CREATE, Api.UPDATE,
    Api.BATCH_DELETE, Api.EXPORT, Api.DICT})
public class UserController extends BaseController<UserService, UserResp, UserDetailResp, UserQuery, UserReq> {

    @Operation(summary = "下载导入模板", description = "下载导入模板")
    @SaCheckPermission("system:user:import")
    @GetMapping(value = "/import/template", produces = MediaType.APPLICATION_OCTET_STREAM_VALUE)
    public void downloadImportTemplate(HttpServletResponse response) throws IOException {
        baseService.downloadImportTemplate(response);
    }

    @Operation(summary = "解析导入数据", description = "解析导入数据")
    @SaCheckPermission("system:user:import")
    @PostMapping("/import/parse")
    public UserImportParseResp parseImport(@RequestPart @NotNull(message = "文件不能为空") MultipartFile file) {
        ValidationUtils.throwIf(file::isEmpty, "文件不能为空");
        return baseService.parseImport(file);
    }

    @Operation(summary = "重置密码", description = "重置用户登录密码")
    @Parameter(name = "id", description = "ID", example = "1", in = ParameterIn.PATH)
    @SaCheckPermission("system:user:resetPwd")
    @PatchMapping("/{id}/password")
    public void resetPassword(@RequestBody @Valid UserPasswordResetReq req, @PathVariable Long id) {
        String newPassword = SecureUtils.decryptPasswordByRsaPrivateKey(req.getNewPassword(), "新密码解密失败", true);
        req.setNewPassword(newPassword);
        baseService.resetPassword(req, id);
    }
}
```

**自定义方法规范：**

1. 必须添加 `@Operation` 注解，包含 `summary` 和 `description`
2. 必须添加 `@SaCheckPermission` 进行权限校验
3. 使用 `@PathVariable` 时必须添加 `@Parameter` 注解说明
4. 请求参数必须使用 `@Valid` 进行校验
5. Controller 只做参数校验和调用 Service，不写业务逻辑

#### 1.1.4 Controller 与多个 Service 依赖

```java
@Tag(name = "角色管理 API")
@Validated
@RestController
@RequiredArgsConstructor
@CrudRequestMapping(value = "/system/role", api = {Api.LIST, Api.GET, Api.CREATE, Api.UPDATE, Api.BATCH_DELETE,
    Api.DICT})
public class RoleController extends BaseController<RoleService, RoleResp, RoleDetailResp, RoleQuery, RoleReq> {

    // 通过构造器注入其他 Service（@RequiredArgsConstructor 自动处理）
    private final UserRoleService userRoleService;
    private final MenuService menuService;

    @Operation(summary = "查询角色权限树列表", description = "查询角色权限树列表")
    @SaCheckPermission("system:role:updatePermission")
    @GetMapping("/permission/tree")
    public List<RolePermissionResp> listPermissionTree() {
        List<Tree<Long>> treeList = menuService.tree(null, null, false);
        return BeanUtil.copyToList(treeList, RolePermissionResp.class);
    }
}
```

#### 1.1.5 Controller 钩子方法（preHandle）

可以重写 `preHandle` 方法在执行前进行额外校验或处理：

```java
@Override
public void preHandle(CrudApi crudApi, Object[] args, Method targetMethod, Class<?> targetClass) throws Exception {
    super.preHandle(crudApi, args, targetMethod, targetClass);
    Api api = crudApi.value();
    if (!(Api.CREATE.equals(api) || Api.UPDATE.equals(api))) {
        return;
    }
    MenuReq req = (MenuReq)args[0];
    Boolean isExternal = ObjectUtil.defaultIfNull(req.getIsExternal(), false);
    String path = req.getPath();
    ValidationUtils.throwIf(Boolean.TRUE.equals(isExternal) && !URLUtils
        .isHttpUrl(path), "路由地址格式不正确，请以 http:// 或 https:// 开头");
    // 非外链菜单参数修正
    if (Boolean.FALSE.equals(isExternal)) {
        ValidationUtils.throwIf(URLUtils.isHttpUrl(path), "路由地址格式不正确");
        req.setPath(StrUtil.isBlank(path) ? path : StrUtil.prependIfMissing(path, StringConstants.SLASH));
        req.setName(StrUtil.removePrefix(req.getName(), StringConstants.SLASH));
        req.setComponent(StrUtil.removePrefix(req.getComponent(), StringConstants.SLASH));
    }
}
```

---

### 1.2 Service 层规范

#### 1.2.1 Service 接口定义

Service **必须是接口**，不能直接写实现类。

```java
/**
 * 用户业务接口
 *
 * @author Charles7c
 * @since 2022/12/21 21:48
 */
public interface UserService extends BaseService<UserResp, UserDetailResp, UserQuery, UserReq>, IService<UserDO> {

    /**
     * 下载导入模板
     *
     * @param response 响应对象
     * @throws IOException /
     */
    void downloadImportTemplate(HttpServletResponse response) throws IOException;

    /**
     * 解析导入数据
     *
     * @param file 导入文件
     * @return 解析结果
     */
    UserImportParseResp parseImport(MultipartFile file);

    /**
     * 重置密码
     *
     * @param req 请求参数
     * @param id  ID
     */
    void resetPassword(UserPasswordResetReq req, Long id);

    /**
     * 根据用户名查询
     *
     * @param username 用户名
     * @return 用户信息
     */
    UserDO getByUsername(String username);
}
```

**关键要点：**

1. 继承 `BaseService<Resp, DetailResp, Query, Req>` - 提供通用 CRUD 方法
2. 继承 `IService<DO>` - MyBatis Plus 的 Service 接口
3. 所有方法必须有中文 JavaDoc 注释
4. 参数和返回值必须明确类型

#### 1.2.2 ServiceImpl 实现类

```java
/**
 * 用户业务实现
 *
 * @author Charles7c
 * @since 2022/12/21 21:49
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class UserServiceImpl extends BaseServiceImpl<UserMapper, UserDO, UserResp, UserDetailResp, UserQuery, UserReq> implements UserService {

    // 依赖注入（通过构造器注入，@RequiredArgsConstructor 自动生成）
    private final PasswordEncoder passwordEncoder;
    private final UserPasswordHistoryService userPasswordHistoryService;
    private final UserRoleService userRoleService;
    private final OptionService optionService;

    // 使用 @Resource 注入可能存在循环依赖的 Service
    @Resource
    private DeptService deptService;

    // 使用 @Value 注入配置
    @Value("${avatar.support-suffix}")
    private String[] avatarSupportSuffix;

    @Override
    public PageResp<UserResp> page(UserQuery query, PageQuery pageQuery) {
        QueryWrapper<UserDO> queryWrapper = this.buildQueryWrapper(query);
        super.sort(queryWrapper, pageQuery);
        IPage<UserDetailResp> page = baseMapper.selectUserPage(new Page<>(pageQuery.getPage(), pageQuery
            .getSize()), queryWrapper);
        PageResp<UserResp> pageResp = PageResp.build(page, super.getListClass());
        pageResp.getList().forEach(this::fill);
        return pageResp;
    }

    @Override
    public void beforeCreate(UserReq req) {
        String password = SecureUtils.decryptPasswordByRsaPrivateKey(req.getPassword(), "密码解密失败", true);
        req.setPassword(password);
        this.checkUsernameRepeat(req.getUsername(), null);
        this.checkEmailRepeat(req.getEmail(), null, "邮箱为 [{}] 的用户已存在");
        this.checkPhoneRepeat(req.getPhone(), null, "手机号为 [{}] 的用户已存在");
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public void afterCreate(UserReq req, UserDO user) {
        Long userId = user.getId();
        baseMapper.lambdaUpdate().set(UserDO::getPwdResetTime, LocalDateTime.now()).eq(UserDO::getId, userId).update();
        // 保存用户和角色关联
        userRoleService.assignRolesToUser(req.getRoleIds(), userId);
    }

    @Override
    @CacheInvalidate(name = CacheConstants.USER_KEY_PREFIX, key = "#id")
    public void resetPassword(UserPasswordResetReq req, Long id) {
        // 业务逻辑实现
    }
}
```

**关键要点：**

1. **类注解组合**
   - `@Slf4j` - Lombok 自动生成日志对象
   - `@Service` - 标记为 Spring Service
   - `@RequiredArgsConstructor` - Lombok 自动生成构造器注入

2. **继承 BaseServiceImpl**
   - 第一个泛型：Mapper 接口类型
   - 第二个泛型：实体类型 (DO)
   - 第三个泛型：列表响应类型
   - 第四个泛型：详情响应类型
   - 第五个泛型：查询条件类型
   - 第六个泛型：请求参数类型

3. **依赖注入方式**
   - 优先使用构造器注入（通过 `@RequiredArgsConstructor`）
   - 循环依赖时使用 `@Resource` 字段注入
   - 配置值使用 `@Value` 注入

4. **事务管理**
   - 涉及写操作的方法必须添加 `@Transactional(rollbackFor = Exception.class)`

5. **缓存注解**
   - `@CacheInvalidate` - 删除缓存
   - `@CacheUpdate` - 更新缓存

#### 1.2.3 Service 钩子方法

BaseServiceImpl 提供了丰富的钩子方法，可以在特定时机执行自定义逻辑：

```java
// 创建前校验
@Override
public void beforeCreate(UserReq req) {
    // 参数校验、唯一性检查等
}

// 创建后处理
@Override
@Transactional(rollbackFor = Exception.class)
public void afterCreate(UserReq req, UserDO user) {
    // 关联数据创建、缓存更新等
}

// 更新前校验
@Override
public void beforeUpdate(UserReq req, Long id) {
    // 参数校验、权限检查等
}

// 更新后处理
@Override
@Transactional(rollbackFor = Exception.class)
public void afterUpdate(UserReq req, UserDO user, UserDO oldUser) {
    // 关联数据更新、缓存更新等
}

// 删除前校验
@Override
public void beforeDelete(Long id) {
    // 关联检查、权限检查等
}

// 删除后处理
@Override
@Transactional(rollbackFor = Exception.class)
public void afterDelete(Long id, UserDO user) {
    // 关联数据删除、缓存清理等
}
```

---

### 1.3 Mapper 层规范

#### 1.3.1 Mapper 接口定义

```java
/**
 * 用户 Mapper
 *
 * @author Charles7c
 * @since 2022/12/22 21:47
 */
@Mapper
public interface UserMapper extends DataPermissionMapper<UserDO> {

    /**
     * 分页查询列表
     *
     * @param page         分页条件
     * @param queryWrapper 查询条件
     * @return 分页列表信息
     */
    @DataPermission(tableAlias = "t1")
    IPage<UserDetailResp> selectUserPage(@Param("page") IPage<UserDO> page,
                                         @Param(Constants.WRAPPER) QueryWrapper<UserDO> queryWrapper);

    /**
     * 查询列表
     *
     * @param queryWrapper 查询条件
     * @return 列表信息
     */
    @DataPermission(tableAlias = "t1")
    List<UserDetailResp> selectUserList(@Param(Constants.WRAPPER) QueryWrapper<UserDO> queryWrapper);

    /**
     * 根据用户名查询
     *
     * @param username 用户名
     * @return 用户信息
     */
    @Select("SELECT * FROM sys_user WHERE username = #{username} AND deleted = 0")
    UserDO selectByUsername(@Param("username") String username);

    /**
     * 根据手机号查询
     *
     * @param phone 手机号
     * @return 用户信息
     */
    @Select("SELECT * FROM sys_user WHERE phone = #{phone} AND deleted = 0")
    UserDO selectByPhone(@FieldEncrypt @Param("phone") String phone);
}
```

**关键要点：**

1. 必须添加 `@Mapper` 注解
2. 继承 `DataPermissionMapper<DO>` - 提供数据权限功能
3. 所有方法必须有中文 JavaDoc 注释
4. 自定义查询方法
   - 简单查询使用 `@Select` 注解
   - 复杂查询在 XML 文件中编写
5. 数据权限控制
   - 需要数据权限的查询添加 `@DataPermission(tableAlias = "别名")`
6. 字段加密
   - 敏感字段参数使用 `@FieldEncrypt` 注解

#### 1.3.2 Mapper XML 配置

对应的 XML 文件位于 `src/main/resources/mapper/` 目录下：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="top.continew.admin.system.mapper.user.UserMapper">

    <!-- 分页查询 -->
    <select id="selectUserPage" resultType="top.continew.admin.system.model.resp.user.UserDetailResp">
        SELECT
            t1.id,
            t1.username,
            t1.nickname,
            t1.gender,
            t1.email,
            t1.phone,
            t1.avatar,
            t1.description,
            t1.status,
            t1.is_system,
            t1.pwd_reset_time,
            t2.name AS dept_name,
            t1.dept_id,
            t1.create_user,
            t1.create_time,
            t1.update_user,
            t1.update_time
        FROM sys_user t1
        LEFT JOIN sys_dept t2 ON t1.dept_id = t2.id
        ${ew.customSqlSegment}
    </select>

</mapper>
```

---

### 1.4 Model 层规范

#### 1.4.1 实体类（Entity/DO）

实体类以 `DO` 结尾，继承 `BaseDO`：

```java
/**
 * 用户实体
 *
 * @author Charles7c
 * @since 2022/12/21 20:42
 */
@Data
@DictModel(labelKey = "nickname", extraKeys = {"username"})
@TableName("sys_user")
public class UserDO extends BaseDO {

    @Serial
    private static final long serialVersionUID = 1L;

    /**
     * 用户名
     */
    private String username;

    /**
     * 昵称
     */
    private String nickname;

    /**
     * 密码
     */
    @FieldEncrypt(encryptor = PasswordEncoderEncryptor.class)
    private String password;

    /**
     * 性别
     */
    private GenderEnum gender;

    /**
     * 邮箱
     */
    @FieldEncrypt
    @TableField(insertStrategy = FieldStrategy.NOT_EMPTY)
    private String email;

    /**
     * 手机号码
     */
    @FieldEncrypt
    @TableField(insertStrategy = FieldStrategy.NOT_EMPTY)
    private String phone;

    /**
     * 状态
     */
    private DisEnableStatusEnum status;

    /**
     * 是否为系统内置数据
     */
    private Boolean isSystem;

    /**
     * 部门 ID
     */
    private Long deptId;
}
```

**关键要点：**

1. 使用 `@Data` 注解（Lombok）
2. 继承 `BaseDO` - 包含公共字段（id、createUser、createTime 等）
3. 使用 `@TableName` 指定数据库表名
4. 添加 `serialVersionUID`
5. 所有字段必须有中文注释
6. 枚举类型直接使用枚举类
7. 敏感字段使用 `@FieldEncrypt` 加密
8. 字段策略使用 `@TableField` 配置

#### 1.4.2 请求参数（Req）

请求参数以 `Req` 结尾，实现 `Serializable`：

```java
/**
 * 用户创建或修改请求参数
 *
 * @author Charles7c
 * @since 2023/2/20 21:03
 */
@Data
@Schema(description = "用户创建或修改请求参数")
public class UserReq implements Serializable {

    @Serial
    private static final long serialVersionUID = 1L;

    /**
     * 用户名
     */
    @Schema(description = "用户名", example = "zhangsan")
    @NotBlank(message = "用户名不能为空")
    @Pattern(regexp = RegexConstants.USERNAME, message = "用户名长度为 4-64 个字符，支持大小写字母、数字、下划线，以字母开头")
    private String username;

    /**
     * 昵称
     */
    @Schema(description = "昵称", example = "张三")
    @NotBlank(message = "昵称不能为空")
    @Pattern(regexp = RegexConstants.GENERAL_NAME, message = "昵称长度为 2-30 个字符，支持中文、字母、数字、下划线，短横线")
    private String nickname;

    /**
     * 密码
     */
    @Schema(description = "密码", example = "RSA 公钥加密的密码")
    @NotBlank(message = "密码不能为空", groups = CrudValidationGroup.Create.class)
    private String password;

    /**
     * 邮箱
     */
    @Schema(description = "邮箱", example = "123456789@qq.com")
    @Length(max = 255, message = "邮箱长度不能超过 {max} 个字符")
    @Email(message = "邮箱格式不正确")
    private String email;

    /**
     * 手机号
     */
    @Schema(description = "手机号", example = "13811111111")
    @Mobile
    private String phone;

    /**
     * 性别
     */
    @Schema(description = "性别", example = "1")
    @NotNull(message = "性别无效")
    private GenderEnum gender;

    /**
     * 所属部门
     */
    @Schema(description = "所属部门", example = "5")
    @NotNull(message = "所属部门不能为空")
    private Long deptId;

    /**
     * 所属角色
     */
    @Schema(description = "所属角色", example = "2")
    @NotEmpty(message = "所属角色不能为空")
    private List<Long> roleIds;
}
```

**关键要点：**

1. 使用 `@Data` 注解
2. 使用 `@Schema` 描述 API 文档
3. 添加 `serialVersionUID`
4. 所有字段必须有中文注释
5. 使用 Jakarta Validation 注解进行参数校验：
   - `@NotBlank` - 字符串非空
   - `@NotNull` - 对象非空
   - `@NotEmpty` - 集合非空
   - `@Pattern` - 正则校验
   - `@Email` - 邮箱校验
   - `@Length` - 长度校验
   - `@Mobile` - 手机号校验（自定义）
6. 使用 `groups` 区分创建和修改的校验规则

#### 1.4.3 响应参数（Resp）

响应参数以 `Resp` 结尾，继承 `BaseDetailResp`：

```java
/**
 * 用户响应参数
 *
 * @author Charles7c
 * @since 2023/2/20 21:08
 */
@Data
@Schema(description = "用户响应参数")
@Assemble(key = "id", props = @Mapping(src = "roleId", ref = "roleIds"), sort = 0, container = ContainerConstants.USER_ROLE_ID_LIST, handlerType = OneToManyAssembleOperationHandler.class)
public class UserResp extends BaseDetailResp {

    @Serial
    private static final long serialVersionUID = 1L;

    /**
     * 用户名
     */
    @Schema(description = "用户名", example = "zhangsan")
    private String username;

    /**
     * 昵称
     */
    @Schema(description = "昵称", example = "张三")
    private String nickname;

    /**
     * 性别
     */
    @Schema(description = "性别", example = "1")
    private GenderEnum gender;

    /**
     * 邮箱
     */
    @Schema(description = "邮箱", example = "c*******@126.com")
    @JsonMask(MaskType.EMAIL)
    private String email;

    /**
     * 手机号码
     */
    @Schema(description = "手机号码", example = "188****8888")
    @JsonMask(MaskType.MOBILE_PHONE)
    private String phone;

    /**
     * 部门 ID
     */
    @Schema(description = "部门 ID", example = "5")
    private Long deptId;

    /**
     * 所属部门
     */
    @Schema(description = "所属部门", example = "测试部")
    private String deptName;

    /**
     * 角色 ID 列表
     */
    @Schema(description = "角色 ID 列表", example = "2")
    @Assemble(props = @Mapping(src = "name", ref = "roleNames"), container = ContainerConstants.USER_ROLE_NAME_LIST, handlerType = ManyToManyAssembleOperationHandler.class)
    private List<Long> roleIds;

    /**
     * 角色名称列表
     */
    @Schema(description = "角色名称列表", example = "测试人员")
    private List<String> roleNames;

    @Override
    public Boolean getDisabled() {
        return this.getIsSystem() || Objects.equals(this.getId(), UserContextHolder.getUserId());
    }
}
```

**关键要点：**

1. 继承 `BaseDetailResp` - 包含公共响应字段
2. 使用 `@Schema` 描述 API 文档
3. 使用 `@JsonMask` 进行数据脱敏
4. 使用 `@Assemble` 进行关联数据自动装配
5. 可以重写 `getDisabled()` 方法自定义禁用逻辑

#### 1.4.4 查询条件（Query）

查询条件以 `Query` 结尾，实现 `Serializable`：

```java
/**
 * 用户查询条件
 *
 * @author Charles7c
 * @since 2023/2/20 21:06
 */
@Data
@Schema(description = "用户查询条件")
public class UserQuery implements Serializable {

    @Serial
    private static final long serialVersionUID = 1L;

    /**
     * 关键词
     */
    @Schema(description = "关键词", example = "张三")
    private String description;

    /**
     * 部门 ID
     */
    @Schema(description = "部门 ID", example = "1")
    private Long deptId;

    /**
     * 状态
     */
    @Schema(description = "状态", example = "1")
    private DisEnableStatusEnum status;

    /**
     * 创建时间
     */
    @Schema(description = "创建时间")
    private List<LocalDateTime> createTime;
}
```

---

### 1.5 常用注解详解

#### 1.5.1 权限注解

```java
// 1. 忽略认证（无需登录即可访问）
@SaIgnore

// 2. 检查权限（需要指定权限才能访问）
@SaCheckPermission("system:user:create")

// 3. 检查角色
@SaCheckRole("admin")

// 4. 登录校验
@SaCheckLogin
```

#### 1.5.2 校验注解

```java
// 1. 字符串非空
@NotBlank(message = "用户名不能为空")

// 2. 对象非空
@NotNull(message = "性别无效")

// 3. 集合非空
@NotEmpty(message = "角色列表不能为空")

// 4. 正则校验
@Pattern(regexp = RegexConstants.USERNAME, message = "用户名格式不正确")

// 5. 邮箱校验
@Email(message = "邮箱格式不正确")

// 6. 长度校验
@Length(min = 2, max = 30, message = "昵称长度为 2-30 个字符")

// 7. 手机号校验（自定义）
@Mobile

// 8. 分组校验
@NotBlank(message = "密码不能为空", groups = CrudValidationGroup.Create.class)
```

#### 1.5.3 缓存注解

```java
// 1. 缓存失效
@CacheInvalidate(name = CacheConstants.USER_KEY_PREFIX, key = "#id")

// 2. 缓存更新
@CacheUpdate(name = CacheConstants.USER_KEY_PREFIX, key = "#id", value = "#result")

// 3. 缓存查询
@Cached(name = CacheConstants.USER_KEY_PREFIX, key = "#id", expire = 3600)
```

#### 1.5.4 MyBatis Plus 注解

```java
// 1. 表名映射
@TableName("sys_user")

// 2. 主键配置
@TableId(type = IdType.AUTO)

// 3. 字段映射
@TableField(value = "user_name")

// 4. 插入策略
@TableField(insertStrategy = FieldStrategy.NOT_EMPTY)

// 5. 逻辑删除
@TableLogic
```

#### 1.5.5 数据权限注解

```java
// 数据权限控制
@DataPermission(tableAlias = "t1")
```

#### 1.5.6 字段加密注解

```java
// 1. 普通加密
@FieldEncrypt

// 2. 密码加密
@FieldEncrypt(encryptor = PasswordEncoderEncryptor.class)
```

---

### 1.6 工具类使用规范

#### 1.6.1 Hutool 工具类

项目大量使用 Hutool 工具类，常用的有：

```java
// 1. 字符串工具
StrUtil.isBlank(str)              // 判断空字符串
StrUtil.isEmpty(str)              // 判断null或空
StrUtil.format("用户{}不存在", name) // 格式化字符串
StrUtil.removePrefix(str, "/")    // 移除前缀
StrUtil.prependIfMissing(str, "/") // 添加前缀（如果缺失）

// 2. 对象工具
ObjectUtil.isNull(obj)            // 判断null
ObjectUtil.defaultIfNull(obj, defaultValue) // 默认值
ObjectUtil.equal(obj1, obj2)      // 对象比较

// 3. 集合工具
CollUtil.isEmpty(list)            // 判断空集合
CollUtil.isNotEmpty(list)         // 判断非空集合
CollUtil.newArrayList(1, 2, 3)    // 创建ArrayList

// 4. Bean 工具
BeanUtil.copyProperties(source, target) // 属性复制
BeanUtil.copyToList(sourceList, TargetClass.class) // 列表复制

// 5. 日期工具
DateUtil.parse("2023-01-01")     // 解析日期
DateUtil.format(date, "yyyy-MM-dd") // 格式化日期

// 6. 文件工具
FileNameUtil.extName(fileName)   // 获取扩展名
FileUtil.readUtf8String(file)    // 读取文件
```

#### 1.6.2 项目工具类

```java
// 1. 校验工具
ValidationUtils.throwIf(condition, "错误消息")  // 条件校验
ValidationUtils.throwIfNull(obj, "对象不能为空") // 非空校验

// 2. 安全工具
SecureUtils.decryptPasswordByRsaPrivateKey(password, "解密失败", true)

// 3. 用户上下文
UserContextHolder.getUserId()     // 获取当前用户ID
UserContextHolder.getUsername()   // 获取当前用户名

// 4. Redis 工具
RedisUtils.set(key, value)        // 设置缓存
RedisUtils.get(key)               // 获取缓存
RedisUtils.delete(key)            // 删除缓存
RedisUtils.deleteByPattern(pattern) // 批量删除

// 5. 集合工具（ContiNew）
CollUtils.convertList(list, Type::getId) // 转换列表
```

---

## 二、前端开发标准

### 2.1 页面组件结构

#### 2.1.1 列表页面基本结构

```vue
<template>
  <GiPageLayout>
    <!-- 左侧树形菜单（可选） -->
    <template #left>
      <DeptTree @node-click="handleSelectDept" />
    </template>

    <!-- 主表格 -->
    <GiTable
      row-key="id"
      :data="dataList"
      :columns="columns"
      :loading="loading"
      :scroll="{ x: '100%', y: '100%', minWidth: 1500 }"
      :pagination="pagination"
      :disabled-tools="['size']"
      :disabled-column-keys="['nickname']"
      @refresh="search"
    >
      <!-- 顶部查询表单 -->
      <template #top>
        <GiForm
          v-model="queryForm"
          search
          :columns="queryFormColumns"
          size="medium"
          @search="search"
          @reset="reset"
        />
      </template>

      <!-- 左侧工具栏 -->
      <template #toolbar-left>
        <a-button v-permission="['system:user:create']" type="primary" @click="onAdd">
          <template #icon><icon-plus /></template>
          <template #default>新增</template>
        </a-button>
        <a-button v-permission="['system:user:import']" @click="onImport">
          <template #icon><icon-upload /></template>
          <template #default>导入</template>
        </a-button>
      </template>

      <!-- 右侧工具栏 -->
      <template #toolbar-right>
        <a-button v-permission="['system:user:export']" @click="onExport">
          <template #icon><icon-download /></template>
          <template #default>导出</template>
        </a-button>
      </template>

      <!-- 自定义列插槽 -->
      <template #nickname="{ record }">
        <GiCellAvatar :avatar="record.avatar" :name="record.nickname" />
      </template>

      <template #gender="{ record }">
        <GiCellGender :gender="record.gender" />
      </template>

      <template #status="{ record }">
        <GiCellStatus :status="record.status" />
      </template>

      <!-- 操作列 -->
      <template #action="{ record }">
        <a-space>
          <a-link v-permission="['system:user:get']" @click="onDetail(record)">详情</a-link>
          <a-link v-permission="['system:user:update']" @click="onUpdate(record)">修改</a-link>
          <a-dropdown>
            <a-button type="text" size="mini">
              <template #icon><icon-more :size="16" /></template>
            </a-button>
            <template #content>
              <a-doption v-permission="['system:user:resetPwd']" @click="onResetPwd(record)">
                重置密码
              </a-doption>
              <a-doption v-permission="['system:user:delete']">
                <a-link status="danger" :disabled="record.isSystem" @click="onDelete(record)">
                  删除
                </a-link>
              </a-doption>
            </template>
          </a-dropdown>
        </a-space>
      </template>
    </GiTable>

    <!-- 弹窗组件 -->
    <AddDrawer ref="AddDrawerRef" @save-success="search" />
    <DetailDrawer ref="DetailDrawerRef" />
  </GiPageLayout>
</template>

<script setup lang="ts">
import type { TableInstance } from '@arco-design/web-vue'
import AddDrawer from './AddDrawer.vue'
import DetailDrawer from './DetailDrawer.vue'
import { type UserResp, deleteUser, exportUser, listUser } from '@/apis/system/user'
import { DisEnableStatusList } from '@/constant/common'
import { useDownload, useResetReactive, useTable } from '@/hooks'
import { isMobile } from '@/utils'
import has from '@/utils/has'
import type { ColumnItem } from '@/components/GiForm'

defineOptions({ name: 'SystemUser' })

// 查询表单
const [queryForm, resetForm] = useResetReactive({
  sort: ['t1.id,desc'],
})

// 查询表单配置
const queryFormColumns: ColumnItem[] = reactive([
  {
    type: 'input',
    label: '用户名',
    field: 'description',
    span: { xs: 24, sm: 8, xxl: 8 },
    props: {
      placeholder: '用户名/昵称/描述',
    },
  },
  {
    type: 'select',
    label: '状态',
    field: 'status',
    span: { xs: 24, sm: 6, xxl: 8 },
    props: {
      options: DisEnableStatusList,
      placeholder: '请选择状态',
    },
  },
  {
    type: 'range-picker',
    label: '创建时间',
    field: 'createTime',
    span: { xs: 24, sm: 10, xxl: 8 },
  },
])

// 表格数据和操作
const {
  tableData: dataList,
  loading,
  pagination,
  search,
  handleDelete,
} = useTable((page) => listUser({ ...queryForm, ...page }), { immediate: false })

// 表格列配置
const columns: TableInstance['columns'] = [
  {
    title: '序号',
    width: 66,
    align: 'center',
    render: ({ rowIndex }) => h('span', {}, rowIndex + 1 + (pagination.current - 1) * pagination.pageSize),
    fixed: !isMobile() ? 'left' : undefined,
  },
  {
    title: '昵称',
    dataIndex: 'nickname',
    slotName: 'nickname',
    minWidth: 140,
    ellipsis: true,
    tooltip: true,
    fixed: !isMobile() ? 'left' : undefined,
  },
  { title: '用户名', dataIndex: 'username', minWidth: 140 },
  { title: '状态', dataIndex: 'status', slotName: 'status', align: 'center' },
  { title: '性别', dataIndex: 'gender', slotName: 'gender', align: 'center' },
  { title: '手机号', dataIndex: 'phone', minWidth: 170 },
  { title: '创建时间', dataIndex: 'createTime', width: 180 },
  {
    title: '操作',
    dataIndex: 'action',
    slotName: 'action',
    width: 160,
    align: 'center',
    fixed: !isMobile() ? 'right' : undefined,
    show: has.hasPermOr(['system:user:get', 'system:user:update', 'system:user:delete']),
  },
]

// 重置
const reset = () => {
  resetForm()
  search()
}

// 删除
const onDelete = (record: UserResp) => {
  return handleDelete(() => deleteUser(record.id), {
    content: `是否确定删除用户「${record.nickname}(${record.username})」？`,
  })
}

// 导出
const onExport = () => {
  useDownload(() => exportUser(queryForm))
}

// 新增
const AddDrawerRef = ref()
const onAdd = () => {
  AddDrawerRef.value?.onOpen()
}

// 修改
const onUpdate = (record: UserResp) => {
  AddDrawerRef.value?.onOpen(record.id)
}

// 详情
const DetailDrawerRef = ref()
const onDetail = (record: UserResp) => {
  DetailDrawerRef.value?.onOpen(record.id)
}
</script>
```

**关键要点：**

1. 使用 `GiPageLayout` 作为页面布局容器
2. 使用 `GiTable` 组件展示表格数据
3. 使用 `GiForm` 组件构建查询表单
4. 使用 `useTable` Hook 管理表格状态
5. 使用 `v-permission` 指令控制按钮权限
6. 使用插槽自定义列显示
7. 操作列使用下拉菜单折叠次要操作

### 2.2 表单组件规范

#### 2.2.1 抽屉表单（AddDrawer）

```vue
<template>
  <a-drawer
    v-model:visible="visible"
    :title="title"
    :mask-closable="false"
    :esc-to-close="false"
    :width="width >= 500 ? 500 : '100%'"
    @before-ok="save"
    @close="reset"
  >
    <GiForm ref="formRef" v-model="form" :columns="columns" />
  </a-drawer>
</template>

<script setup lang="ts">
import { Message, type TreeNodeData } from '@arco-design/web-vue'
import { useWindowSize } from '@vueuse/core'
import { addUser, getUser, updateUser } from '@/apis/system/user'
import { type ColumnItem, GiForm } from '@/components/GiForm'
import type { Gender, Status } from '@/types/global'
import { GenderList } from '@/constant/common'
import { useResetReactive } from '@/hooks'
import { useDept, useRole } from '@/hooks/app'
import { encryptByRsa } from '@/utils/encrypt'

const emit = defineEmits<{
  (e: 'save-success'): void
}>()

const { width } = useWindowSize()

const dataId = ref('')
const visible = ref(false)
const isUpdate = computed(() => !!dataId.value)
const title = computed(() => (isUpdate.value ? '修改用户' : '新增用户'))
const formRef = ref<InstanceType<typeof GiForm>>()
const { roleList, getRoleList } = useRole()
const { deptList, getDeptList } = useDept()

// 表单数据
const [form, resetForm] = useResetReactive({
  gender: 1 as Gender,
  status: 1 as Status,
})

// 表单配置
const columns: ColumnItem[] = reactive([
  {
    label: '昵称',
    field: 'nickname',
    type: 'input',
    span: 24,
    required: true,
    props: {
      maxLength: 30,
    },
  },
  {
    label: '用户名',
    field: 'username',
    type: 'input',
    span: 24,
    required: true,
    props: {
      maxLength: 64,
    },
  },
  {
    label: '密码',
    field: 'password',
    type: 'input-password',
    span: 24,
    required: true,
    props: {
      maxLength: 32,
      showWordLimit: true,
    },
    hide: () => isUpdate.value,
  },
  {
    label: '手机号码',
    field: 'phone',
    type: 'input',
    span: 24,
    props: {
      maxLength: 11,
    },
  },
  {
    label: '邮箱',
    field: 'email',
    type: 'input',
    span: 24,
    props: {
      maxLength: 255,
    },
  },
  {
    label: '性别',
    field: 'gender',
    type: 'radio-group',
    span: 24,
    props: {
      options: GenderList,
    },
  },
  {
    label: '所属部门',
    field: 'deptId',
    type: 'tree-select',
    span: 24,
    required: true,
    props: {
      data: deptList,
      allowClear: true,
      allowSearch: true,
      fallbackOption: false,
      filterTreeNode(searchKey: string, nodeData: TreeNodeData) {
        if (nodeData.title) {
          return nodeData.title.toLowerCase().includes(searchKey.toLowerCase())
        }
        return false
      },
    },
  },
  {
    label: '角色',
    field: 'roleIds',
    type: 'select',
    span: 24,
    required: true,
    props: {
      options: roleList,
      multiple: true,
      allowClear: true,
      allowSearch: true,
    },
  },
  {
    label: '描述',
    field: 'description',
    type: 'textarea',
    span: 24,
  },
  {
    label: '状态',
    field: 'status',
    type: 'switch',
    span: 24,
    props: {
      type: 'round',
      checkedValue: 1,
      uncheckedValue: 2,
    },
  },
])

// 打开抽屉
const onOpen = async (id = '') => {
  visible.value = true
  dataId.value = id

  // 加载依赖数据
  await Promise.all([getRoleList(), getDeptList()])

  // 编辑时加载数据
  if (id) {
    const res = await getUser(id)
    Object.assign(form, res.data)
  }
}

// 保存
const save = async () => {
  const valid = await formRef.value?.validateForm()
  if (!valid) return false

  try {
    const data = { ...form }

    // 密码加密
    if (data.password) {
      data.password = encryptByRsa(data.password)
    }

    if (isUpdate.value) {
      await updateUser(data, dataId.value)
      Message.success('修改成功')
    } else {
      await addUser(data)
      Message.success('新增成功')
    }

    emit('save-success')
    return true
  } catch (error) {
    return false
  }
}

// 重置
const reset = () => {
  formRef.value?.resetForm()
  resetForm()
}

defineExpose({ onOpen })
</script>
```

**关键要点：**

1. 使用 `a-drawer` 组件作为容器
2. 使用 `GiForm` 组件构建表单
3. 使用 `useResetReactive` Hook 管理表单状态
4. 通过 `defineExpose` 暴露 `onOpen` 方法
5. 保存时进行表单校验
6. 密码等敏感字段需要加密
7. 使用 `emit` 通知父组件刷新

### 2.3 API 调用规范

#### 2.3.1 API 文件结构

API 文件位于 `src/apis/` 目录，按模块划分：

```typescript
// src/apis/system/user.ts
import type * as T from './type'
import http from '@/utils/http'
import type { LabelValueState } from '@/types/global'

const BASE_URL = '/system/user'

/** @desc 查询用户列表 */
export function listUser(query: T.UserPageQuery) {
  return http.get<PageRes<T.UserResp[]>>(`${BASE_URL}`, query)
}

/** @desc 查询所有用户列表 */
export function listAllUser(query: Partial<T.UserPageQuery>) {
  return http.get<T.UserResp[]>(`${BASE_URL}/list`, query)
}

/** @desc 查询用户详情 */
export function getUser(id: string) {
  return http.get<T.UserDetailResp>(`${BASE_URL}/${id}`)
}

/** @desc 新增用户 */
export function addUser(data: any) {
  return http.post(`${BASE_URL}`, data)
}

/** @desc 修改用户 */
export function updateUser(data: any, id: string) {
  return http.put(`${BASE_URL}/${id}`, data)
}

/** @desc 删除用户 */
export function deleteUser(id: string) {
  return http.del(`${BASE_URL}`, { ids: [id] })
}

/** @desc 导出用户 */
export function exportUser(query: T.UserQuery) {
  return http.download(`${BASE_URL}/export`, query)
}

/** @desc 重置密码 */
export function resetUserPwd(data: any, id: string) {
  return http.patch(`${BASE_URL}/${id}/password`, data)
}

/** @desc 查询用户字典 */
export function listUserDict(query?: { status: number }) {
  return http.get<LabelValueState[]>(`${BASE_URL}/dict`, query)
}
```

**关键要点：**

1. 定义 `BASE_URL` 常量
2. 所有函数必须添加 `@desc` 注释
3. 使用 TypeScript 类型定义参数和返回值
4. 使用统一的 `http` 工具类
5. RESTful 风格：
   - `GET` - 查询
   - `POST` - 新增
   - `PUT` - 修改
   - `DELETE` - 删除
   - `PATCH` - 部分更新
6. 下载文件使用 `http.download`

#### 2.3.2 类型定义文件

```typescript
// src/apis/system/type.ts
import type { PageQuery } from '@/types/global'

/** 用户查询条件 */
export interface UserQuery {
  description?: string
  deptId?: number
  status?: number
  createTime?: string[]
}

/** 用户分页查询 */
export interface UserPageQuery extends UserQuery, PageQuery {}

/** 用户响应 */
export interface UserResp {
  id: string
  username: string
  nickname: string
  gender: number
  email: string
  phone: string
  avatar: string
  status: number
  isSystem: boolean
  description: string
  deptId: number
  deptName: string
  roleIds: number[]
  roleNames: string[]
  createTime: string
  updateTime: string
}

/** 用户详情响应 */
export interface UserDetailResp extends UserResp {
  // 额外的详情字段
}
```

### 2.4 常用组件使用

#### 2.4.1 GiTable 组件

```vue
<GiTable
  row-key="id"
  :data="dataList"
  :columns="columns"
  :loading="loading"
  :scroll="{ x: '100%', y: '100%', minWidth: 1500 }"
  :pagination="pagination"
  :disabled-tools="['size']"
  :disabled-column-keys="['nickname']"
  @refresh="search"
>
  <!-- 插槽 -->
</GiTable>
```

**配置项：**
- `row-key` - 行唯一标识
- `data` - 表格数据
- `columns` - 列配置
- `loading` - 加载状态
- `scroll` - 滚动配置
- `pagination` - 分页配置
- `disabled-tools` - 禁用的工具
- `disabled-column-keys` - 禁用列设置的字段

#### 2.4.2 GiForm 组件

```vue
<GiForm
  ref="formRef"
  v-model="form"
  :columns="columns"
  search
  size="medium"
  @search="search"
  @reset="reset"
/>
```

**配置项：**
- `v-model` - 表单数据
- `columns` - 表单项配置
- `search` - 是否为查询表单
- `size` - 表单大小
- `@search` - 查询事件
- `@reset` - 重置事件

#### 2.4.3 GiCell 系列组件

```vue
<!-- 头像 -->
<GiCellAvatar :avatar="record.avatar" :name="record.nickname" />

<!-- 性别 -->
<GiCellGender :gender="record.gender" />

<!-- 状态 -->
<GiCellStatus :status="record.status" />

<!-- 标签 -->
<GiCellTags :data="record.roleNames" />
```

### 2.5 Hooks 使用规范

#### 2.5.1 useTable

```typescript
const {
  tableData: dataList,
  loading,
  pagination,
  search,
  handleDelete,
} = useTable((page) => listUser({ ...queryForm, ...page }), {
  immediate: false
})
```

**返回值：**
- `tableData` - 表格数据
- `loading` - 加载状态
- `pagination` - 分页信息
- `search` - 搜索方法
- `handleDelete` - 删除处理方法

#### 2.5.2 useResetReactive

```typescript
const [queryForm, resetForm] = useResetReactive({
  sort: ['t1.id,desc'],
})
```

**返回值：**
- 第一个元素：响应式数据对象
- 第二个元素：重置方法

#### 2.5.3 useDownload

```typescript
const onExport = () => {
  useDownload(() => exportUser(queryForm))
}
```

#### 2.5.4 useDept / useRole

```typescript
const { deptList, getDeptList } = useDept()
const { roleList, getRoleList } = useRole()

// 加载数据
await getDeptList()
await getRoleList()
```

---

## 三、通用开发规范

### 3.1 文件命名规范

#### 3.1.1 后端文件命名

- Controller：`XxxController.java`
- Service 接口：`XxxService.java`
- Service 实现：`XxxServiceImpl.java`
- Mapper：`XxxMapper.java`
- Entity：`XxxDO.java`
- 请求参数：`XxxReq.java`
- 响应参数：`XxxResp.java`
- 查询条件：`XxxQuery.java`
- 枚举：`XxxEnum.java`
- 常量：`XxxConstants.java`
- 工具类：`XxxUtils.java`

#### 3.1.2 前端文件命名

- 页面组件：小写字母 + 连字符，如 `index.vue`
- 子组件：大驼峰，如 `AddDrawer.vue`
- API 文件：小写字母，如 `user.ts`
- 类型文件：`type.ts`
- 工具文件：小写字母，如 `index.ts`

### 3.2 代码注释规范

#### 3.2.1 后端注释

```java
/**
 * 用户管理 API
 *
 * @author Charles7c
 * @since 2023/2/20 21:00
 */
public class UserController {

    /**
     * 重置密码
     *
     * @param req 请求参数
     * @param id  ID
     */
    public void resetPassword(UserPasswordResetReq req, Long id) {
        // 业务逻辑
    }
}
```

#### 3.2.2 前端注释

```typescript
/** @desc 查询用户列表 */
export function listUser(query: T.UserPageQuery) {
  return http.get<PageRes<T.UserResp[]>>(`${BASE_URL}`, query)
}
```

### 3.3 Git 提交规范

提交信息格式：`类型: 描述`

**类型：**
- feat：新功能
- fix：修复 Bug
- docs：文档更新
- style：代码格式调整
- refactor：重构
- test：测试
- chore：构建/工具链更新

**示例：**
```
feat: 新增用户管理模块
fix: 修复用户删除时的权限校验问题
docs: 更新开发规范文档
```

### 3.4 最佳实践

1. **后端**
   - Controller 只做参数校验和调用 Service
   - Service 层实现所有业务逻辑
   - 使用钩子方法代替直接重写 CRUD 方法
   - 多使用 Lombok 减少样板代码
   - 使用 Hutool 工具类提高开发效率
   - 事务方法必须添加 `@Transactional`
   - 敏感数据必须加密存储

2. **前端**
   - 使用 Composition API
   - 使用 TypeScript 进行类型约束
   - 使用 Hooks 复用逻辑
   - 组件拆分要合理
   - API 调用统一使用封装的方法
   - 权限控制使用 `v-permission` 指令

3. **通用**
   - 所有代码必须有中文注释
   - 禁止使用 emoji 或颜文字
   - 代码格式化保持一致
   - 变量命名要见名知义
   - 及时清理无用代码
   - 定期提交 Git

---

## 附录

### A. 常用正则表达式

```java
// RegexConstants.java
public static final String USERNAME = "^[a-zA-Z][a-zA-Z0-9_]{3,63}$";
public static final String GENERAL_NAME = "^[\\u4e00-\\u9fa5a-zA-Z0-9_-]{2,30}$";
public static final String PASSWORD = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d]{8,32}$";
```

### B. 常用枚举

```java
// GenderEnum - 性别
UNKNOWN(0, "未知"),
MALE(1, "男"),
FEMALE(2, "女");

// DisEnableStatusEnum - 状态
DISABLE(2, "禁用"),
ENABLE(1, "启用");
```

### C. 常用缓存 Key

```java
// CacheConstants.java
public static final String USER_KEY_PREFIX = "user:";
public static final String ROLE_KEY_PREFIX = "role:";
public static final String MENU_KEY_PREFIX = "menu:";
public static final String ROLE_MENU_KEY_PREFIX = "role:menu:";
```

---

**文档说明：**

本文档基于 ContiNew Admin 项目 system 模块的实际代码分析总结，覆盖了后端和前端的完整开发规范。所有示例代码均来自真实项目，可直接参考使用。

在实际开发中，应严格遵循本规范，确保代码质量和项目一致性。如有疑问或需要补充，请及时更新本文档。
